.nolist
#include "ti84pcse.inc"
#include "dcse8.inc"
.list
.variablename U2048

    .org UserMem
BinaryStart:
    .db $DE,$2A,"N",$BB,$B4,$BB,$B4,$BB,$B3,$BB,$C3,")D"   ;Disp "Needs D
    .db $BB,$BF,$BB,$BF,$BB,$C2,$BB,$C3,")CSE",$2A,$3F     ;oors CSE"
    .db $EF,$11                                            ;OpenLib(
    .db "D",$BB,$BF,$BB,$BF,$BB,$C2,$BB,$C3,"CSE",$11,$3F  ;(tokenized "DoorsCSE")
    .db $EF,$12,$3F                                        ;ExecLib
    .db $D5,$3F                                            ;Return
    .db tExtTok,tAsm84CPrgm,$3F                            ;Asm84CPrgm
HeaderStart:
    .dw ASMStart-HeaderStart        ;offset to code
    ; Header sections start here

    .dw 10
    .db ASMHEADER_FIELD_TYPE_LIB    ;== 3
    .db "DoorsCSE",8,1              ;Lib name, min major version, min minor version

    .dw endDCSIcon - startDCSIcon
    .db ASMHEADER_FIELD_TYPE_ICON
startDCSIcon:
    .db 1 ;1 bit color
    .dw BEFFh ;BG
    .dw 20EEh ;FG (big endian, yellow)
    .db 32, 32 ;Size
    .incbmp "assets/2048_icon.png"
endDCSIcon:

    .dw endDCSDesc - startDCSDesc
    .db ASMHEADER_FIELD_TYPE_DESC
startDCSDesc:
    .db "2048 for CSE!",0
endDCSDesc:

    .dw endDCSAuthor - startDCSAuthor
    .db ASMHEADER_FIELD_TYPE_AUTH
startDCSAuthor:
    .db "Unknownloner",0
endDCSAuthor:

    ;.dw 0
    ;.db ASMHEADER_FIELD_TYPE_HALFRES

    .dw 0     ;End of header field: 0 bytes of data
    .db $ff   ;End of header field: type 255
ASMStart:
.relocate UserMem
.varloc saveSScreen, 300h
.var 32, board
prev_board = board + 16 ;Used to store previous board state for comparing for changes
.var 32, save_board ;Used by the game over checker, since prev_board and alt_board are used already
.var 16, alt_board  ;Used as alternate board storage when we don't want to use prev_board
.var 3, score ;Score is 24 bit int cause I'm not sure how big it can get.
    ld a,1
    out (20h),a
    call SetupInterrupt

    ;Right hand side of screen
    ld h,119
    ld l,0
    ld d,41
    ld e,240
    ld bc,FFDDh
    call ColorRectangle
    call InitGame

    ld de,65535
    call AddToScore
    ld de,32044
    call AddToScore
    call DrawScore

    call GameLoop

    call RestoreInterrupt
    xor a
    out (20h),a
    ret


;Adds DE to the score
;Destroys HL,DE
AddToScore:
    ld hl,(score)
    add hl,de ;Add low bits
    ld (score),hl
    ret nc ;No carry, don't inc high bits
    ld hl,score + 2
    inc (hl)
    ret

;Adds the value of a tile ID to the score, preserves all registers
;In other words, Score += 2^Tile
;A: Tile
AddTileToScore:
    push af
    push hl
    push de
    dec a ;No entry for tile ID 0
    add a,a
    ld hl,TwosPowerTable
    ld d,0
    ld e,a
    add hl,de
    ld e,(hl) \ inc hl
    ld d,(hl)
    call AddToScore
    pop de
    pop hl
    pop af
    ret

TwosPowerTable:
.dw 2
.dw 4
.dw 8
.dw 16
.dw 32
.dw 64
.dw 128
.dw 256
.dw 512
.dw 1024
.dw 2048
.dw 4096
.dw 8192
.dw 16384 ;Nobody is gonna get this value lol


;Initialize game data and screen
InitGame:
    ld hl,0
    ld (score),hl
    ld (score + 1),hl

    call ClearBoard
    call GenTile
    call GenTile
    call DrawBoard
    call DrawScore
    ret

;Game loop logic:
;While clear not pressed
;   NumRotations = Case key of
;       Left:  0
;       Up:    1
;       Right: 2
;       Down:  3
;   For NumRotations
;       Rotate90
;   Copy board -> old board
;   MoveBoardLeft
;   If board != old board
;       If board is full
;           Lose
;       Else
;           Gen tile
;   For (4 - NumRotations)
;       Rotate90
GameLoop:
    call WaitForKey
    bit 6,a ;Clear key
    ret z
    call GameStep
    call DrawTiles
    jr GameLoop

GameStep:
    rra ;Down
    jr c,$+4
    ld b,3
    rra ;Left
    jr c,$+4
    ld b,0
    rra ;Right
    jr c,$+4
    ld b,2
    rra ;Up
    jr c,$+4
    ld b,1

    push bc ;Save num rotations
    ;Save board state
    ld hl,board
    ld de,prev_board
    ld bc,16
    ldir
    pop bc

    ld a,b
    push bc
    call RotateBoardN
    call MoveBoardLeft
    ;Unrotate board
    pop bc ;BC = num rotations
    ld a,4
    sub b
    ld b,a
    call RotateBoardN

    call ScanBoardChanges
    ;Z = no changes, NZ = changes
    ret z

    ;Board changed, spawn tile
    call GenTile
    call IsGameOver ;Is the game now over?
    jp z,LoseGame
    ret

LoseGame:
    ;Speed this part up
    di
    call DrawTiles ;Display results of losing move
    call LightenBoard
    ld h,34
    ld l,93
    ld ix,GameOverPic
    call DrawSpriteTransparent
    ei
    call WaitForKey
    call InitGame
    ret


;Checks if game is over by attempting to move board left, up, right, and down.
;Set NZ if game not over, Z if game over
IsGameOver:
    ;Save an extra copy of the board/prevboard at save_board
    ld hl,board
    ld de,save_board
    ld bc,32
    ldir

    ld b,4

_gameOverLp:
    push bc

    ld hl,board
    ld de,prev_board
    ld bc,16
    ldir

    call MoveBoardLeft
    call ScanBoardChanges
    jr z,{@}
    ;NZ, board changed, return NZ for game not over

    ld hl,save_board
    ld de,board
    ld bc,32
    ldir
    pop bc ;Drop loop counter from stack

    xor a \ inc a ;Set NZ
    ret
    @:
    call RotateBoard90
    pop bc
    djnz _gameOverLp
    ld hl,save_board
    ld de,board
    ld bc,32
    ldir
    xor a ;Set Z
    ret

;Compares board to prev_board
;If there was a change, return NZ, else Z
ScanBoardChanges:
    ld hl,board
    ld de,prev_board
    ld b,16
_scanChanges:
    ld a,(de)
    cp (hl)
    ret nz
    inc hl \ inc de
    djnz _scanChanges
    ;Z flag should be set at this point
    ret

;Pseudo-code for algorithm
;For Row, 0, 3
;   For Col, 0, 2
;       tile = TileAt(Col, Row)
;       If tile > 0
;           For Off, Col, 3
;               If TileAt(Off, Row) == tile
;                   TileSet(Col, Row, tile + 1)
;                   TileSet(Off, Row, 0)
;                   break
;       Else
;           For Off, Col, 3
;               If TileAt(Off, Row) != 0
;                   TileSet(Col, Row, TileAt(Off, Row))
;                   TileSet(Off, Row, 0)
;                   break
;
MoveBoardLeft:
    ld ix,board
    ld e,4 ;Row counter
_lpRow: ;For rows
    ld c,3 ;Col counter
    _lpCol: ;For columns
        ld b,c ;Number of columns to scan to the right

        push ix \ pop hl \ inc hl ;HL = scanner pointer

        ld a,(ix) ;Current tile
        or a
        jr nz,_scanNum
        _scanZero: ;Scan for any tile
            ld a,(hl)
            or a
            jr z,{@}
            ;Tile != 0
            ld (hl),0
            ld (ix),a
            jr _scanNum ;Now that tile has been moved, continue scanning to see if another can be combined with it
            @:
            inc hl
            djnz _scanZero
            jr _scanOver
        _scanNum:  ;Scan for matching tile
            ld a,(hl)
            cp (ix)
            jr nz,{@}
            ;Tiles match
            ld (hl),0
            inc (ix)
            inc a ;A = (ix)
            call AddTileToScore
            jr _scanOver
            @:
            ;Tiles didn't match
            or a
            jr nz,_scanOver ;If tiles didn't match and it wasn't an empty tile, stop scan
            inc hl
            djnz _scanNum
        _scanOver:
        inc ix
        dec c
        jr nz, _lpCol
    inc ix ;Extra inc to next row since we only start scans at 3 columns
    dec e
    jr nz, _lpRow
    ret

;Rotates board data 90 degrees counter-clockwise
;Later should make this an algorithm I guess
RotateBoard90:
    ld a,(board + 3h) \ ld (alt_board + 0h),a
    ld a,(board + 7h) \ ld (alt_board + 1h),a
    ld a,(board + Bh) \ ld (alt_board + 2h),a
    ld a,(board + Fh) \ ld (alt_board + 3h),a
    ld a,(board + 2h) \ ld (alt_board + 4h),a
    ld a,(board + 6h) \ ld (alt_board + 5h),a
    ld a,(board + Ah) \ ld (alt_board + 6h),a
    ld a,(board + Eh) \ ld (alt_board + 7h),a
    ld a,(board + 1h) \ ld (alt_board + 8h),a
    ld a,(board + 5h) \ ld (alt_board + 9h),a
    ld a,(board + 9h) \ ld (alt_board + Ah),a
    ld a,(board + Dh) \ ld (alt_board + Bh),a
    ld a,(board + 0h) \ ld (alt_board + Ch),a
    ld a,(board + 4h) \ ld (alt_board + Dh),a
    ld a,(board + 8h) \ ld (alt_board + Eh),a
    ld a,(board + Ch) \ ld (alt_board + Fh),a

    ld hl,alt_board
    ld de,board
    ld bc,16
    ldir
    ret

;Rotates 90 * b degrees
;Input: B - num times to rotate
RotateBoardN:
    push bc
    call RotateBoard90
    pop bc
    djnz RotateBoardN
    ret

;D - X
;E - Y
;Output: HL = addr
;Destroy A
GetTileAddr:
    ld a,e
    add a,a
    add a,a ;Y * 4
    add a,d ;Y * 4 + x
    ld h,board >> 8
    add a,board
    jr nc,$+3
    inc h
    ld l,a
    ret

;D - X
;E - Y
;A - Tile
SetTile:
    push af
    call GetTileAddr
    pop af
    ld (hl),a
    ret

;Generates a new tile on the board.
;90% chance of 2, 10% chance of 4
GenTile:
    ;Find open x/y position.
    ld b,16
    call RandInt
    ld h,board >> 8
    add a,board
    jr nc,$+3
    inc h
    ld l,a
    ld a,(hl)
    or a
    jr nz,GenTile

    push hl
    ld b,255
    call RandInt
    cp 228
    ld a,1
    jr c,$+3 ;If rand num was >= 228, gen 4
    inc a
    pop hl
    ld (hl),a
    ret

;Draws the initial board
DrawBoard:
    ld hl,0
    ld d,119
    ld e,240
    ld bc,BD74h
    call ColorRectangle
    jp DrawTiles

;Draws the 24bit num score with VPutMap
penFGColor = A036h
penBGColor = A038h
DrawScore:
    ld hl,242
    ld (penCol),hl
    ld a,80
    ld (penRow),a
    ld hl,0000h
    ld (penBGColor),hl
    ld hl,FFFFh
    ld (penFGColor),hl

    ld hl,score
    call ConvertToBCD

    ld hl,bcdScratch
    call DispBCD
    ret

;Converts a 24bit int at HL to BCD
;Convert to BCD with double dabble
;Handles up to a 10 digit number
.var 10, bcdScratch
.var 3, bcdSource
ConvertToBCD:
    ld de,bcdSource
    ld bc,3
    ldir
    ld ix,bcdSource

    xor a
    ld hl,bcdScratch
    ld b,10
_zeroScratch:
    ld (hl),a
    inc hl
    djnz _zeroScratch

    ld b,24
    _bcdConvLp:
        ;Do increment
        ld c,10
        ld hl,bcdScratch
        _bcdIncLp:
            ld a,(hl)
            cp 5
            jr c,$+4
            add a,3
            ld (hl),a
            inc hl
            dec c
            jr nz,_bcdIncLp

        sla (ix)
        rl (ix + 1)
        rl (ix + 2)

        ld c,10
        ld hl,bcdScratch
        _bcdShiftLp:
            ld a,(hl)
            rla
            bit 4,a
            jr z,{@}
            and %1111
            scf ;Set carry if bit 4 set
            @:
            ld (hl),a
            inc hl
            dec c
            jr nz,_bcdShiftLp
        djnz _bcdConvLp
    ret


;Displays the 10 digit BCD value at HL
;1 byte per digit
DispBCD:
    ld de,9
    add hl,de ;Go to end

    ;Skip leading zeroes, except if the value IS zero
    ld b,9
_skipLeadingZeroes:
    ld a,(hl)
    or a
    jr nz,{@}
    dec hl
    djnz _skipLeadingZeroes
@:
    inc b ;B = num digits to display
_dispBCDDigits:
    ld a,(hl)
    add a,'0'
    push hl
    push bc
    b_call(_VPutMap)
    pop bc
    pop hl
    dec hl
    djnz _dispBCDDigits
    ei
    ret

;Draws tiles of board
DrawTiles:
    ;Unrolled loop for simplicity
    .for _x, 0, 3
        .for _y, 0, 3
            ld h,_x
            ld l,_y

            ld a,((_y * 4) + _x + prev_board)
            ld c,a

            ld a,((_y * 4) + _x + board)
            cp c
            call nz, DrawTile ;Only draw tile if the tile has changed
        .loop
    .loop
    ret

ClearBoard:
    ld hl,board
    ld de,prev_board
    ld a,FFh
    ld b,16
_clrBoardLp:
        ld (hl),0
        ld (de),a
        inc hl
        inc de
        djnz _clrBoardLp
    ret

;H - Tile X
;L - Tile Y
;A - Tile type
DrawTile:
    cp 13
    jr c,$+4 ;If tile > 13, set it to 13. That way the LCD doesn't crash or something
    ld a,13

    push af
    push hl
    ld d,0
    ld e,h
    ld bc,29 ;(x is div 2)
    call MultDEBC
    pop de  ;X,Y
    push hl ;Save X
    ld d,0  ;DE = Y
    ld bc,58
    call MultDEBC ;HL = Y
    pop de        ;DE = X

    ld bc,7
    add hl,bc ;Y += 7
    ex de,hl
    ld bc,3
    add hl,bc ;X += 3 (x is div 2)
    ;HL = X, DE = Y

    ld h,l ;H = x
    ld l,e ;L = y
    pop af ;A = tile ID

    ;Fill color
    push af
    add a,a
    add a,a ;A *= 4 since each color table entry is 4 bytes

    ld d,TileColorTable >> 8
    add a,TileColorTable
    jr nc,$+3
    inc d
    ld e,a
    ld a,(de) \ inc de
    ld b,a
    ld a,(de)
    ld c,a

    push hl ;Save X/Y
    ld d,26
    ld e,52
    call ColorRectangle

    pop hl ;X/Y
    pop af ;A = tile ID
    or a
    ret z ;If tile == 0, ret now, no text
    dec a ;Tile 0 has no sprite, therefor Tile 1 = Sprite 0

    ld d,0
    ld e,h    ;DE = X
    ex de,hl
    add hl,hl ;X *= 2
    ex de,hl


    ld h,0    ;HL = y + 19
    ld bc,19
    add hl,bc ;Get to center of tile

    push hl
    push de

    ld h,a
    ld e,(7 * 14) + 2 + 2 ;Size of sprite data
    call MultHE
    ld de,TileSprites
    add hl,de
    push hl
    pop ix ;IX = pointer to sprite

    ;Position
    pop de
    pop hl

    jp DrawSprite_1Bit

;Draws a bit-packed sprite with transparent background and text-colored foreground
;H - X
;L - Y
;IX - data
;   Data format: width, height, (width / 8 * height) (2 bytes), pixels
DrawSpriteTransparent:
    ld a,lrWinLeft
    out (10h),a
    out (10h),a
    xor a  \ out (11h),a
    ld a,h \ out (11h),a

    ld a,lrCol
    out (10h),a
    out (10h),a
    xor a  \ out (11h),a
    ld a,h \ out (11h),a

    ;Add width - 1, result in DE
    ld d,0
    ld a,h
    add a,(ix)
    jr nc,$+3
    inc d
    ld e,a
    dec de

    ld a,lrWinRight
    out (10h),a
    out (10h),a
    ld a,d \ out (11h),a
    ld a,e \ out (11h),a

    ld a,lrWinTop
    out (10h),a
    out (10h),a
    xor a  \ out (11h),a
    ld a,l \ out (11h),a

    ld a,lrRow
    out (10h),a
    out (10h),a
    xor a  \ out (11h),a
    ld a,l \ out (11h),a

    ;Add height - 1, result in DE
    ld d,0
    ld a,l
    add a,(ix + 1)
    jr nc,$+3
    inc d
    ld e,a
    dec de

    ld a,lrWinBottom
    out (10h),a
    out (10h),a
    ld a,d \ out (11h),a
    ld a,e \ out (11h),a

    ld c,(ix + 2)
    ld b,(ix + 3)

    inc ix \ inc ix \ inc ix \ inc ix ;IX = pixels

    ld a,lrGram
    out (10h),a
    out (10h),a

    ld hl,736Ch ;Foreground

_drawRow:
    push bc
    ld a,(ix)
    ld bc,(8 << 8) | 11h
    _drawCol:
        rla
        jr nc,_drawBG
        _drawFG:
            out (c),h
            out (c),l
            djnz _drawCol
            jr _drawColDone
        _drawBG:
            ;Dummy
            in d,(c)
            in d,(c)
            ;Actual
            in d,(c)
            in e,(c)
            out (c),d
            out (c),e
            djnz _drawCol
        _drawColDone:
    inc ix
    pop bc
    dec bc
    ld a,b
    or c
    jr nz,_drawRow
    ret


;Applies the lightening mask that you get for a game over
;240 * 238
;The original uses rgba(238, 228, 218, 0.73)
;This means that
;   R = 0.933 * 0.73 + (DST * 0.27)
;   G = 0.894 * 0.73 + (DST * 0.27)
;   B = 0.855 * 0.73 + (DST * 0.27)
;Or
;   0.68 + DST / 3.7
;   0.65 + DST / 3.7
;   0.62 + DST / 3.7
;We can approximate this (with RGB 5-6-5 vals) as
;   21 + DST >> 2
;   40 + DST >> 2
;   19 + DST >> 2
;Bit shift can be done in one step as
;   DST = (DST >> 2) & (%0011100111100111)
;And we can gurantee that there will be no overflow between colors.
;so we can add all channels at once too.
LightenBoard:
    ld a,lrWinLeft
    out (10h),a
    out (10h),a
    xor a
    out (11h),a
    out (11h),a

    ld a,lrCol
    out (10h),a
    out (10h),a
    xor a
    out (11h),a
    out (11h),a

    ld a,lrWinRight
    out (10h),a
    out (10h),a
    xor a
    out (11h),a
    ld a,237
    out (11h),a

    ld a,lrWinTop
    out (10h),a
    out (10h),a
    xor a
    out (11h),a
    out (11h),a

    ld a,lrRow
    out (10h),a
    out (10h),a
    xor a
    out (11h),a
    out (11h),a

    ld a,lrWinBottom
    out (10h),a
    out (10h),a
    xor a
    out (11h),a
    ld a,239
    out (11h),a

    ld a,lrGram
    out (10h),a
    out (10h),a

    ;Color to add
    ld bc,(21 << 11) | (40 << 5) | 18

    ld d,240 ;Outer loop
_lightenOuter:
    ld e,238
    _lightenInner:
        ;Dummy
        in a,(11h)
        in a,(11h)

        ;Actual
        in a,(11h)
        ld h,a
        in a,(11h)
        ld l,a

        ;HL >> 2 w/ bit AND
        srl h
        rr l
        srl h
        rr l
        ld a,h
        and %00111001
        ld h,a
        ld a,l
        and %11100111
        ld l,a

        ;Color add
        add hl,bc

        ;Re-write to LCD
        ld a,h
        out (11h),a
        ld a,l
        out (11h),a
        dec e
        jr nz,_lightenInner
    dec d
    jr nz,_lightenOuter
    ret


;Background color for tiles. Also contains foreground colors for text
;so it can be used as sprite palettes
TileColorTable:
.db CEh,16h, 00h,00h ;Empty
.db EFh,3Bh, 73h,6Ch ;Tile 2
.db EFh,19h, 73h,6Ch ;Tile 4
.db F5h,8Fh, FFh,BEh ;Tile 8
.db F4h,ACh, FFh,BEh  ;Tile 16
.db F3h,EBh, FFh,BEh  ;Tile 32
.db F2h,E7h, FFh,BEh  ;Tile 64
.db EEh,6Eh, FFh,BEh  ;Tile 128
.db EEh,6Ch, FFh,BEh  ;Tile 256
.db EEh,4Ah, FFh,BEh  ;Tile 512
.db EEh,27h, FFh,BEh  ;Tile 1024
.db EEh,05h, FFh,BEh  ;Tile 2048
.db 39h,C6h, FFh,BEh  ;Tile 4096
.db 39h,C6h, FFh,BEh  ;Tile 8192


.deflong tileSprite(palette, data)
    .dw palette
    .db 52, 14
    .incbmp data
.enddeflong

TileSprites:
tileSprite(TileColorTable + 4h, "assets/text_2.png")
tileSprite(TileColorTable + 8h, "assets/text_4.png")
tileSprite(TileColorTable + Ch, "assets/text_8.png")
tileSprite(TileColorTable + 10h, "assets/text_16.png")
tileSprite(TileColorTable + 14h, "assets/text_32.png")
tileSprite(TileColorTable + 18h, "assets/text_64.png")
tileSprite(TileColorTable + 1Ch, "assets/text_128.png")
tileSprite(TileColorTable + 20h, "assets/text_256.png")
tileSprite(TileColorTable + 24h, "assets/text_512.png")
tileSprite(TileColorTable + 28h, "assets/text_1024.png")
tileSprite(TileColorTable + 2Ch, "assets/text_2048.png")
tileSprite(TileColorTable + 30h, "assets/text_4096.png")
tileSprite(TileColorTable + 34h, "assets/text_8192.png")

GameOverPic:
.db 176, 53
.dw (176 / 8) * 53
.incbmp "assets/text_gameover.png"


;Wait for clear key, destroys A
.var byte, keyState
WaitForKey:
    halt
    ld a,(keyState)
    or a
    jr z,WaitForKey ;A = 0, keys have not been released
    cp FFh
    jr z,WaitForKey ;A = FFh, no keys pressed
    push af
    xor a
    ld (keyState),a ;Acknowledge key
    pop af
    ret

;Interrupt that scans for keys and sets a byte for the last key pressed
;Key scan protocol:
;   Interrupt gets key code, sets keyState to code
;   WaitForKey reads code, ACKs by setting keyState to 00h
;   If interrupt sees keyState == 00h, it won't set another key until all keys are released
;   before accepting another key press
;It's imperative that this interrupt use no absolute jumps, as it is not .relocated
KeyScanInterrupt:
    exx
    ex af, af' ;'Fix syntax hilight
    ld a,%00000000 ;ACK interrupts
    out (03h),a

    ;Scan keys
    ld a,FFh
    out (01h),a
    ld a,%11111100 ;Clear group and arrow key group
    out (01h),a
    or a
    push hl
    sbc hl,hl
    pop hl

    in a,(01h)
    or %10110000
    ld b,a ;B = key code

    ld a,(keyState)
    or a
    ld a,b ;A = key code
    jr nz,{@}
    ld a,FFh
    cp b
    jr nz,_endKeyScan   ;If not all keys are released, don't set that they are
    @:
    ld (keyState),a
_endKeyScan:
    ld a,%00001010 ;Enable first timer. No on key
    out (03h),a
    exx
    ex af, af' ;'Fix syntax hilight
    ei
    ret
KeyScanInterruptEnd:

interruptTable = 8100h; ramCode
interruptLoc = 8C8Ch ;statVars
SetupInterrupt:
    di
    ;Copy interrupt to StatVars
    ld hl,KeyScanInterrupt
    ld de,interruptLoc
    ld bc,KeyScanInterruptEnd - KeyScanInterrupt
    ldir

    ;Set up interrupt table
    ld a,interruptLoc
    ld hl,interruptTable
    ld b,0
_writeJumpTable:
        ld (hl),a
        inc hl
        djnz _writeJumpTable
    ld (hl),a ;257'th byte of table

    ld a,interruptTable >> 8
    ld i,a
    ld a,%00001010 ;Enable first timer. No on key.
    out (03h),a

    ld a,%00000010
    out (04h),a ;Faster interrupt speed

    ld a,FFh
    ld (keyState),a ;Set keystate to all released
    im 2
    ei
    ret


;Restore OS interrupts
RestoreInterrupt:
    di
    ld a,0Bh
    out (03h),a ;Normal interrupt sources

    ld a,%00000110
    out (04h),a ;Normal interrupt speed

    im 1
    b_call(_DelRes) ;We trashed star vars
    ei
    ret

.endrelocate
